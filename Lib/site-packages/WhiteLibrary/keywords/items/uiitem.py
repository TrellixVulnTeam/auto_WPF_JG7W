import xlrd
import xlwt
import csv
import os
import shutil
import pandas as pd
from io import StringIO
from robot.utils import timestr_to_secs
from TestStack.White.UIItems import UIItem  # noqa: F401 #pylint: disable=unused-import
from WhiteLibrary.keywords.librarycomponent import LibraryComponent
from WhiteLibrary.keywords.robotlibcore import keyword
from WhiteLibrary.utils.click import Clicks
from WhiteLibrary.utils.wait import Wait
from robotide import log
from WhiteLibrary.keywords import window




class UiItemKeywords(LibraryComponent):
    @keyword
    def click_item(self, locator, x_offset=0, y_offset=0):
        """Clicks an item.

        ``locator`` is the locator of the item or object of an item.
        Locator syntax is explained in `Item locators`.

        Optional arguments ``x_offset`` and ``y_offset`` can be used to define the coordinates to click at,
        relative to the center of the item.
        """
        item = self.state._get_item_by_locator(locator)
        Clicks.click(item, x_offset, y_offset)

    @keyword
    def right_click_item(self, locator, x_offset=0, y_offset=0):
        """Right clicks an item.

        ``locator`` is the locator of the item or object of an item.
        Locator syntax is explained in `Item locators`.

        Optional arguments ``x_offset`` and ``y_offset`` can be used to define the coordinates to click at,
        relative to the center of the item.
        """
        item = self.state._get_item_by_locator(locator)
        Clicks.right_click(item, x_offset, y_offset)

    @keyword
    def double_click_item(self, locator, x_offset=0, y_offset=0):
        """Double clicks an item.

        ``locator`` is the locator of the item or object of an item.
        Locator syntax is explained in `Item locators`.

        Optional arguments ``x_offset`` and ``y_offset`` can be used to define the coordinates to click at,
        relative to the center of the item.
        """
        item = self.state._get_item_by_locator(locator)
        Clicks.double_click(item, x_offset, y_offset)

    @keyword
    def get_items(self, locator):
        """Returns a list of items that match the given ``locator``.

        Locator syntax is explained in `Item locators`.
        """
        return self.state._get_multiple_items_by_locator(locator)
    
    @keyword
    def log_Structure(self):
        """Returns a list of items that match the given ``locator``.

        Locator syntax is explained in `Item locators`.
        """
        """uitem = self.state.get_application_windows()
        item = self._get_typed_item_by_locator(uitem,locator)
        """
        uitem = self.state.get_application_windows()
        
        uitem[0].LogStructure()
        
    @keyword
    def compare_excel(self,ori_path,tar_path,ori_sub_name,tar_sub_name,ori_col,tar_col,log2,log3):
        wb_ori=xlrd.open_workbook(ori_path) #打开原始文件
        ori_table = wb_ori.sheet_by_name(ori_sub_name)
        col1 = ori_table.col_values(int(ori_col))
        coll1 = list(set(col1))
        print("auto test ==================原文件生成列的 值："+ str(coll1))
        print("auto test ==================原文件生成列的数量："+ str(len(coll1)))
        
        
        
        
        
        wb_tar=xlrd.open_workbook(tar_path) #打开目标文件
        tar_table = wb_tar.sheet_by_name(tar_sub_name)
        col2 = tar_table.col_values(int(tar_col))
        print("auto test ========================================================")
        print("auto test ==================目标件生成列的 值： "+ str(col2))
        print("auto test ==================目标件生成列的数量："+ str(len(col2)))   
    
        
        diff = []
        difflist =[]
    
        for i in coll1:
            if i not in col2:
                diff.append(i)
        print("auto test ==================源文件在目标文件找不到的值："+str(diff))
        print("auto test ==================源文件在目标文件找不到的值数量："+str(len(diff)))
    
        data = open(log2,'w',encoding='utf-16')
        data.write("different**************************\n")
        for m in range(len(diff)):
            data.write(str(diff[m]))
            data.write('\n')
        data.close()
    
        for i in col2:
            if i not in coll1:
                difflist.append(i)
        print("auto test ==================目标文件在源文件找不到的值："+str(difflist))
        print("auto test ==================目标文件在源文件找不到的值数量："+str(len(difflist)))
    
        data = open(log3,'w',encoding='utf-16')
        data.write("different==================\n")
        for m in range(len(difflist)):
            data.write(str(difflist[m]))
            data.write('\n')
        data.close()
        print("Over==========================================over")   
        
    @keyword
    def csv_to_xls(self,csv_path, xls_path):
        with open(csv_path, 'r', encoding='gb18030', errors='ignore') as f:
            data = f.read()
        data_file = StringIO(data)
        print(data_file)
        csv_reader = csv.reader(data_file)
        list_csv = []
        for row in csv_reader:
            list_csv.append(row)
        df_csv = pd.DataFrame(list_csv).applymap(str)
        '''
        这部分是不将csv装换为xls，而是过滤后再写入csv文件
        df_csv = df_csv[(df_csv[4] == '') | (df_csv[4] == 'name')]      # 过滤出第四列包含空值和name的数据
        df_csv.to_csv(csv_path, index=0, header=0, encoding='gb18030')  # 写入csv文件中
        '''
        writer = pd.ExcelWriter(xls_path)
        # 写入Excel
        df_csv.to_excel(
            excel_writer=writer,
            index=False,
            header=False
        )
 
        writer.save()
        
    @keyword
    def txt_to_xls(self,txtFileName,excelFileName):
        # data = pd.read_csv(txtFileName,encoding='utf-8',error_bad_lines=False,sep='|')
        
        data = pd.read_csv(txtFileName,sep='|')
        data.to_excel(excelFileName,sheet_name = "data1")
        print("哈喽")
        
        
            
        
        
    @keyword
    def delete_binfile(self,filepath):
        os.remove(os.path.join(filepath + "\\" ,"Host.bin"))
        
    @keyword
    def delete_csvfile(self,filepath):
        os.remove(os.path.join(filepath + "\\" ,"log.txt"))      

    @keyword
    def copy_file(self,sourfiles,destination):
        shutil.copy2(sourfiles,destination)
        
        
         
        
        
        

    @keyword
    def get_item(self, locator):
        """Returns the first item that matches the given locator.

        ``locator`` is the locator of the item.
        Locator syntax is explained in `Item locators`.
        """
        return self.state._get_item_by_locator(locator)

    @keyword
    def item_should_be_enabled(self, locator):
        """Verifies that an item is enabled.

        ``locator`` is the locator of the item.
        Locator syntax is explained in `Item locators`.
        """
        item = self.state._get_item_by_locator(locator)
        if not item.Enabled:
            raise AssertionError(u"Expected item with locator '{}' to be enabled but found disabled".format(locator))

    @keyword
    def item_should_be_disabled(self, locator):
        """Verifies that an item is disabled.

        ``locator`` is the locator of the item.
        Locator syntax is explained in `Item locators`.
        """
        item = self.state._get_item_by_locator(locator)
        if item.Enabled:
            raise AssertionError(u"Expected item with locator '{}' to be disabled but found enabled".format(locator))

    @keyword
    def wait_until_item_exists(self, locator, timeout):
        """Waits until an item with given locator exists in the attached window.

         Fails if ``timeout`` is exceeded.

        ``locator`` is the locator of the item.
        Locator syntax is explained in `Item locators`.

        ``timeout`` is the maximum time to wait as a Robot time string.

        See `Waiting and timeouts` for more information about waiting in WhiteLibrary.
        """
        Wait.until_true(lambda: self._item_exists(locator),
                        timeout,
                        u"Item with locator '{}' did not exist within {} seconds"
                        .format(locator, timestr_to_secs(timeout)))

    @keyword
    def wait_until_item_does_not_exist(self, locator, timeout):
        """Waits until no items with given locator exist in the attached window.

         Fails if ``timeout`` is exceeded.

        ``locator`` is the locator of the item.
        Locator syntax is explained in `Item locators`.

        ``timeout`` is the maximum time to wait as a Robot time string.

        See `Waiting and timeouts` for more information about waiting in WhiteLibrary.
        """
        Wait.until_true(lambda: not self._item_exists(locator),
                        timeout,
                        u"Item with locator '{}' still existed after {} seconds"
                        .format(locator, timestr_to_secs(timeout)))

    def _item_exists(self, locator):
        search_criteria = self.state._get_search_criteria(locator)
        return self.state.window.Exists(search_criteria)
